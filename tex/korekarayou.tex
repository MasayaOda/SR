%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%      研修A用サンプルファイル     %
%            LATEX2e用             %
%      2001年4月8日 by 三浦        %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4j,twocolumn]{jarticle}
\usepackage{latexsym}
%\usepackage[dvips]{graphicx,color}
\usepackage[dvipdfmx]{graphicx,color}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{cases}
\usepackage{ascmac}
\usepackage{fancybox}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{mathrsfs}
\usepackage{amssymb}
\usepackage{comment}
\usepackage{okumacro}
%\usepackage{multicol}
%\linespread{2.0}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%        原稿サイズ等指定          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\topmargin=-2cm
\leftmargin=0true cm
\oddsidemargin=-1cm 
\evensidemargin=-1cm
\textwidth=17.5cm
\textheight=26cm

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%        自前の命令等設定          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newtheorem{theorem}{定理}
\newtheorem{jexa}{例}
\newtheorem{jcor}{系}
\newtheorem{direc}{方針}
\newcommand{\jpro}{\noindent {\bf 証明}\ \ }
\newtheorem{defi}{定義}
\newtheorem{lemm}{補題}

\newcommand{\bhline}[1]{\noalign{\hrule height #1}}
\newcommand{\cut}[1]{{\rm cut\_from\_hit}(#1)}

\newcommand{\jda}[1]{A_{#1}}
\newcommand{\jitr}{{\rm ITR{\footnotesize{ECONF}}}}
\newcommand{\jdu}{u}
\newcommand{\jdv}{v}
\newcommand{\jdvv}[1] {v_#1}
\newcommand{\jtree}[1]{T_#1}
\newcommand{\jind}[1]{I_#1}
\newcommand{\jpu}{u}
\newcommand{\jpv}{v}

\newcommand{\jsiki}{t}

\newcommand{\jmisr}{最大独立点集合遷移問題}
\newcommand{\jkis}{独立点集合問題}
\newcommand{\jwt}{t}
\newcommand{\jju}{U}
\newcommand{\jjw}{W}
\newcommand{\jwu}[1]{u_{#1}}
\newcommand{\jww}[1]{w_{#1}}
\newcommand{\jws}[1]{s_{#1}}


\renewcommand{\proofname}{証明}

 \makeatletter
    \renewcommand{\thefigure}{%
    \arabic{figure}}
  \makeatother

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%            タイトル              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\twocolumn[
2018 年10月10
日~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~院ゼミ発表用資料\\
\begin{center}
	\begin{huge}
		モンテカルロ法に基づくFlood-ItのAIに関する研究
	\end{huge}
\end{center}

\begin{center}
	\begin{large}
		\textbf{周・伊藤研究室　学部4年　小田将也}
	\end{large}
\end{center}
]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              本文                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{はじめに}
\textbf{Flood-It}とは，$n \times m$の色分けされたグリッド上で行うゲームである．
Flood-Itはグリッドの一番左上にあるマスを\textbf{基準(ピボット)}として進めていくゲームであり，1回の操作でピボットをある色から別のある色へ変更する．ピボットから上下左右に現在の色のみを辿ってたどり着くことができるマスの集合が，
\textbf{自分の領地}であり，ピボットの色の変更と同時に自分の領地の全てのマスの色が同じ色に変わる．
図\ref{oneman}に操作の例を示す．操作前図(a)の斜線で表した3マスが自分の領地であり，
ここにピボットの色を1から2へ変える操作を適用すると，
操作後図(b)のグリッドが得られる．この操作を繰り返し$n \times m$マス全てのマスを自分の領地にすることが目的である．
このとき，操作数が最小となるような操作列を求めることがFlood-Itの問題である．
Flood-Itの問題に関しては，既知の結果としてグリッドの大きさが$n \times n$ならばNP困難\cite{}
$3*n$ならばNP困難\cite{}，$2 \times n$ならどんな色数でも多項式時間で解けることが知られている\cite{}．


今回は，Flood-Itを二人対戦用ゲームにしたものを考える．
二人用Flood-Itは，同じく$n \times m$の色分けされたグリッド上で行う．
一番左上のマスと一番右下のマスを各プレイヤーのピボットとし，
グリッドが二色になるまで交互にピボットの色を変える操作を繰り返す．
最終的に相手プレイヤーよりも自分の領地が広ければ自分の勝ち，というルールである．


本研究では，二人用のFlood-Itに対して，モンテカルロ法に基づく対戦用AIを作成する．


\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width=80mm,clip]{oneman.pdf}
		\caption{1回の操作の例．マス目の中の数字は色を表す．}
		\label{oneman}
	\end{center}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%       基本的な準備・定義        %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%P
\section{定義・準備}
\subsection{グラフ}
無向グラフ$G=(V,E)$を頂点集合$V$と辺集合$E\subseteq V^2$の組とする．本研究では，$G$は単純かつ有限であるとする．$V$の2頂点$\jdu,\jdv$に対して，$\{\jdu,\jdv\}\in E$ならば$\jdu$と$\jdv$は$G$において\textbf{隣接している}という．

グラフ$G=(V,E)$内の点$\jdvv{0}$から点$\jdvv{l}$への歩道$W$は，連続した点の列$\langle \jdvv{0},\jdvv{1},...,\jdvv{l} \rangle$である．ここで，$1\le i\le l$なる各整数について，$\{\jdvv{{i-1}} \jdvv{i}\}\in E$である．このとき，$l$を\textbf{歩道の長さ}という．さらに，$\jdvv{0}$から$\jdvv{l}$への歩道を\textbf{$\langle \jdvv{0},\jdvv{l}\rangle$歩道}と呼ぶ．

$\langle \jdu,\jdv \rangle$歩道に含まれる$\jdu$と$\jdv $以外の全ての頂点が異なるとき，$\langle \jdu,\jdv \rangle$歩道は\textbf{$\langle \jdu,\jdv \rangle$道(パス)}，あるいは単に\textbf{$\jdu$と$\jdv$を結ぶ道(パス)}と呼ばれる．また，長さが正である$\langle \jdu,\jdu \rangle$道は\textbf{閉路(サイクル)}と呼ばれる．
グラフ$G$の任意の2点$\jdu,\jdv \in V$の間に常に$\langle \jdu,\jdv \rangle$道があるとき，$G$は\textbf{連結}であるという．もし$G$に閉路が存在しないかつ連結ならば，$G$は\textbf{木}である．

グラフ$G=(V,E)$，$G^\prime=(V^\prime,E^\prime)$において，$V^\prime \subseteq V$かつ$E^\prime \subseteq E$であるとき，$G^\prime$は$G$の部分グラフという．特に，$E^\prime=\{\{\jdu,\jdv\}\in E\mid \jdu,\jdv\in V^\prime\}$であるとき，$G^\prime$は$G$の\textbf{誘導部分グラフ}という．もし$G^\prime$が木であるならば，$G^\prime$は\textbf{誘導木}という．図\ref{yudougi}は誘導木の例である．


\subsection{誘導木遷移問題}
$G$における二つの誘導木$\jtree{0},\jtree{r}$が与えられたとき，$\jtree{0}$から$\jtree{r}$へ段階的に遷移可能かどうかを判定する問題を\textbf{誘導木遷移問題(\jitr)}という．ここで，誘導木遷移問題において\textbf{段階的に遷移可能}であるとは，以下の条件を満たす誘導木の系列$\langle \jtree{0},\jtree{1},\ldots,\jtree{\ell}\rangle$が存在することをいう．

\begin{itemize}
	\setlength{\itemsep}{-3pt}
	\item 各$i \in \{0,1, \ldots ,\ell\}$に対し，$\jtree{i}$は誘導木であり，$\jtree{\ell}=\jtree{r}$である．
	\item 各$i \in \{0,1, \ldots ,\ell-1\}$に対し，$\jtree{i+1}$は$\jtree{i}$にトークンの操作をちょうど一回行うことで得られる．
\end{itemize}

ここで，誘導木の各頂点にトークンが置かれているとすると，誘導木遷移問題にはTJルール，TSルール，TARルールの三つの\textbf{遷移条件}がある．

TJルールとは各$i \in \{1,2,\ldots,\ell\}$に対し，$\jtree{i-1}\setminus \jtree{i}=\{u\}$かつ$\jtree{i}\setminus \jtree{i-1}=\{v\}$，つまり$u\in \jtree{i-1}$のトークンを$v\in \jtree{i}$へ移して$\jtree{i-1}$から$\jtree{i}$を得ることを表す．

TSルールとは各$i \in \{1,2,\ldots,\ell\}$に対し，$\jtree{i-1}\setminus \jtree{i}=\{u\}$かつ$\jtree{i}\setminus \jtree{i-1}=\{v\}$かつ$\{u,v\}\in E$，つまり$u\in \jtree{i-1}$のトークンを辺$\{u,v\}$に沿って$v\in \jtree{i}$へ移して$\jtree{i-1}$から$\jtree{i}$を得ることを表す．

TARルールとはは各$i \in \{1,2,\ldots,\ell\}$に対し，$|\jtree{i-1}\bigtriangleup \jtree{i}|=1$，つまり$u\in \jtree{i-1}$のトークンを削除，または$u\notin \jtree{i-1}$のトークンを追加して$\jtree{i-1}$から$\jtree{i}$を得ることを表す．

系列$\langle \jtree{0},\jtree{1},\ldots,\jtree{\ell}=\jtree{r}\rangle$を誘導木遷移問題における$\jtree{0}$から$\jtree{r}$への\textbf{遷移列}という．図\ref{senniretu}は誘導木$\jtree{0}$から$\jtree{r}$へのTSルールの下での遷移を表しており，遷移列は$\langle \jtree{0},\jtree{1},\jtree{2}=\jtree{r}\rangle$となる．

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width=90mm,clip]{senniretu.pdf}
		\caption{遷移列の例}
		\label{senniretu}
	\end{center}
\end{figure}

また，\textbf{最短誘導木遷移問題}を$\jtree{0}$から$\jtree{r}$へ長さが高々$\ell$の遷移列において段階的に遷移可能かどうかを判定する問題と定義する．\\

誘導木遷移問題と最短誘導木遷移問題は，TJルールとTSルールにも同様に定義することができる．

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     本論                        %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{TSルールのW[1]困難性}
TSルールの下での\jitr における解サイズを$k$，遷移列の長さを$\ell$と表すこととする．解サイズ$k$と遷移列の長さ$\ell$の二つをパラメータとしたとき，次の定理を示した．




\begin{theorem}\label{jw1the}
	\jitr は\rm{TS}ルールの下で$k+\ell$をパラメータとしたときに\rm{W[1]}困難である．ただし，$k$は誘導木のサイズであり，$\ell$は遷移列の長さである．
\end{theorem}

我々は，\jkis から\jitr へのパラメータ化帰着により，本問題のW[1]困難性を示す．

\jkis は，グラフ$G=(V,E)$と正整数$\jwt$が入力として与えられる．このとき，$S$がグラフ$G$の独立点集合であり，$|S|=\jwt$となるような頂点の部分集合$S\subseteq V$が存在するかを問う問題である．

\jkis について以下の定理が知られている．

\begin{theorem}\rm{(\cite{jiswone})}
	\jkis は独立点集合のサイズ$\jwt$をパラメータとしたときに{\rm W[1]}完全である．
\end{theorem}

まずはインスタンスの構成を与える．

\jkis の任意のインスタンスであるグラフ$G^\prime=(V^\prime,E^\prime)$を考える．これに対して，\jitr のインスタンスを構成するため以下のグラフ$G=(V,E)$を与える．\\
\\
$V=K^\prime \cup \{v,x\}\cup \jju \cup \jjw$\\
$E=\{v,x\}\cup
 \{\{v,y\}\mid y\in K^\prime \cup \jju \cup \jjw \}\cup 
 \{\{\jwu{i},\jww{j}\}\mid i,j=1,\ldots,\jwt+1\}\cup 
 \{\{v_x^i,v_y^j\},\{v_y^i,v_x^j\}\mid  i,j=1,\ldots,\jwt\,i\neq j,x,y=1,\ldots,n,\{v_x,v_y\}\in E^\prime\}\cup 
 \{\{v_a^i,v_a^j\}\mid i,j=1,\ldots,\jwt,i\neq j,a=1,\ldots,n\}$\\
\\
ただし，$\jju=\{\jwu{1},\ldots,\jwu{\jwt+1}\}$，$\jjw=\{\jww{1},\ldots,\jww{\jwt+1}\}$，$V(K_i)=\{v_1^i,v_2^i,\ldots,v_n^i\}(i=1,\ldots n)$，$n=|V^\prime|$であり，$K_1,\ldots,K_\jwt$はグラフ$G^\prime$の頂点集合の完全グラフである．
$K^\prime = K_1\cup \ldots \cup K_\jwt$とする．
また，\jitr の初期解$\jtree{0}$，目標解$\jtree{r}$を$\jtree{0}=\{v,x\}\cup \jju$，$\jtree{r}=\{v,x\}\cup \jjw$とする．
$\jtree{0}$，$\jtree{r}$は誘導木となっている．グラフ$G$の図を図\ref{w1ins}に示す．

\begin{figure*}[htbp]
	\begin{center}
		\includegraphics[width=120mm,clip]{w1ins.pdf}
		\caption{(a)独立点集合問題のグラフ$G$における頂点$v_1,v_2,v_3$およびそれらに接続している辺．(b)インスタンスの構成.二重線は$K_i,i=1,\ldots,\jwt$の全ての頂点に接続していることを表す．また，(a)における独立点集合問題のグラフ$G$の頂点$v_1,v_2,v_3$に対応する頂点$v_1^i,v_2^i,v_3^i(i=1,\ldots,\jwt)$の辺の接続は図のようになっている．ここで$\{v_1^i,v_3^j\}\notin E(i,j=1,\ldots,\jwt,i\neq j)$であることに注意する}
		\label{w1ins}
	\end{center}
\end{figure*}



以下では，定理\ref{jw1the}の証明を与える．

\begin{proof}
	本章で構成したインスタンスを用いる．この構成は，\jkis の入力の多項式時間で行うことができる．また，\jitr の誘導木のサイズおよび遷移列の長さは\jkis の入力の$\jwt$のみに依存している．
	
	次に，グラフ$G^\prime$においてサイズ$\jwt$の独立点集合が存在するとき，かつそのときに限りグラフ$G$において\rm{TS}ルールの下で$\jtree{0}$から$\jtree{r}$へ遷移可能であることを示す．
	
	グラフ$G^\prime$においてサイズ$\jwt$の独立点集合が存在するとき，グラフ$G$において\rm{TS}ルールの下で$\jtree{0}$から$\jtree{r}$へ遷移可能であることを示す．グラフ$G^\prime$においてサイズ$\jwt$の独立点集合が存在するとき，$K_1,\ldots,K_k$において，$G^\prime$のサイズ$\jwt$の独立点集合に対応する頂点集合を考える．
	$K_1$において，$G^\prime$のサイズ$\jwt$の独立点集合に対応する頂点集合から1点$\jws{1}$を選び，$K_2$において，$G^\prime$のサイズ$\jwt$の独立点集合に対応する頂点集合から$K_1$で選んだ頂点と異なる頂点$\jws{2}$を選ぶ．同様に，$K_\jwt$において，$G^\prime$のサイズ$\jwt$の独立点集合に対応する頂点集合から$K_1,\ldots,K_{\jwt-1}$で選んだ頂点と異なる頂点$\jws{\jwt}$を選ぶ．
	このように選んだ頂点の集合を$S=\{\jws{1},\jws{2},\ldots,\jws{\jwt}\}$とする．
	独立点集合の定義より$S$の任意の2点間には辺が存在しないので，$\jtree{S}=\{v,x\}\cup S$は誘導木である．
	したがって，以下のような遷移列を構成することができる．
	まず初めに，各$i\in \{1,\ldots,\jwt\}$における$\jwu{i}\in \jju$のトークンを$S$に移動する．
	次に$\jwu{\jwt+1}$のトークンを$\jww{\jwt+1}$に移動する．
	最後に，$S$のトークンを一つずつ$\jww{i}\in \jjw,i\in \{1,\ldots,\jwt\}$に移動する．以上により，グラフ$G$において\rm{TS}ルールの下で$\jtree{0}$から$\jtree{r}$へ遷移可能である．
	
	グラフ$G$において\rm{TS}ルールの下で$\jtree{0}$から$\jtree{r}$へ遷移可能であるとき，グラフ$G^\prime$においてサイズ$\jwt$の独立点集合が存在することを示す．グラフ$G$において\rm{TS}ルールの下で$\jtree{0}$から$\jtree{r}$へ遷移可能であるとき，$W$の任意の1点に初めてトークンが移動する瞬間があるはずである．
	$v$にトークンが置かれていないとすると非連結となってしまうため，常に$v$にはトークンが置かれており，また$x$にも常にトークンが置かれている．
	$W$の任意の1点に初めてトークンを移動したとき，$\jju$にトークンが残っていると$\jju$の任意の$1$点と$v$と$W$に追加した$1$点で閉路ができてしまう．したがって，$W$の任意の1点に初めてトークンが移動する直前において，$v,x$と$W$の任意の1点に移動するトークン以外の$\jwt$個のトークンはすべて$S$に置かれている．以上により，グラフ$G^\prime$においてサイズ$\jwt$の独立点集合が存在する．
\end{proof}

\begin{table}[h]
	\caption{再帰アルゴリズム}
	\begin{tabular}{l}
		\bhline{1.3pt}
		{\bf アルゴリズム 2}：$Recursive(n)$, $n$:\textbf{整数}  \\ \hline
		\, 1: \textbf{for} $x=n$ to $\lceil n/2 \rceil+1$ \\
		\, 2: ~~$x_3$を$x$番のバケツにmove\\
		\, 3: ~~$x_2$を$x$番のバケツにmove\\
		\, 4: \textbf{end for} \\
		\, 5: \textbf{for} $x=1$ to $n$ \\
		\, 6: ~~1番のバケツから$\lceil n/3 \rceil$番のバケツにある$x_1$\\
		~~~~~~~のボールを$\lceil x/3 \rceil$にリラベルする \\
		\, 7: \textbf{end for} \\
		\, 8: \textbf{if} $\lceil n/3 \rceil$番のバケツに$y_2かy_3(y\in[n])$がある \textbf{then}\\
		\, 9: ~~そのボールを$\lceil n/3 \rceil$にリラベルする \\
		10:  最初の$\lceil n/3 \rceil$個のバケツについて\\
		~~~~~$Recursive(\lceil n/3 \rceil)$を適用しボールを並び替える\\
		11: ラベルを元に戻す \\
		12: \textbf{for} $x=n$ to 2 \\
		13: ~~$x_1$を$x$番のバケツにmove\\
		14: \textbf{end for} \\ \hline 
	\end{tabular} 
	\label{saiki}
\end{table}



\section{まとめと今後の課題}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%            参考文献              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{thebibliography}{9}
\bibitem{jiswone}
R.G. Downey and M.R. Fellows, 
Fixed-parameter tractability and completeness II: on completeness for W[1], 
Theoretical Computer Science 141(1-2), pp. 109--131, 1995.

\bibitem{jTS}
R.A. Hearn and E.D. Demaine, 
PSPACE-completeness of sliding-block puzzles and other problems through the nondeterministic constraint logic model of computation,  Theoretical Computer Science 343(1-2), pp. 72--96, 2005

\bibitem{jTAR}
T. Ito, E.D. Demaine, N.J.A. Harvey, C.H. Papadimitriou, M. Sideri, R. Uehara and Y. Uno, 
On the complexity of reconfiguration problems, 
Theoretical Computer Science 412(12-14), pp. 1054--1065, 2011

\bibitem{jTJ}
M. Kami${\rm \acute{n}}$ski, P. Medvedev and M. Milani${\rm \acute{c}}$, 
Complexity of independent set reconfigurability problems, 
Theoretical Computer Science 439, pp. 9--15, 2012

\bibitem{jITS}
M. Karo${\rm \acute{n}}$ski and Z. Palka,  
On the size of a maximal induced tree in a random graph, 
Mathematica Slovaca 30, pp. 151--155, 1980 

\bibitem{jmeta}
A.E. Mouawad, N. Nishimura, V. Raman, N. Simjour and A. Suzuki, 
On the parameterized complexity of reconfiguration problems, 
Algorithmica 78(1) , pp. 274--297, 2017

\begin{comment}
\bibitem{jkihaba}
A.E. Mouawad, N. Nishimura, V. Raman, M. Wrochna, 
Reconfiguration over tree decompositions, 
Proceedings of The 9th International Symposium on Parameterized and Exact Computation (IPEC 2014), 
Lecture Notes in Computer Science 8894, pp. 246--257, 2014
\end{comment}

\bibitem{jITRe}
K. Wasa, K. Yamanaka and H. Arimura, 
The complexity of induced tree reconfiguration problems, 
Proceedings of The 10th International Conference on Language and Automata Theory and Applications (LATA 2016), Lecture Notes in Computer Science 9618, pp. 330--342, 2016

\end{thebibliography}

\end{document}